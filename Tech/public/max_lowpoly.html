<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Low‑poly 16:9 PNG</title>
  <style>
    body { margin:0; background:#111; color:#eee; font-family:system-ui,sans-serif; display:grid; place-items:center; gap:12px; padding:16px; }
    #wrap { display:grid; gap:8px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; }
    canvas { max-width:90vw; height:auto; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); }
    label { display:inline-flex; gap:6px; align-items:center; }
    input[type="color"], input[type="number"] { height:36px; }
    button { height:36px; padding:0 12px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="wrap">
    <div class="row">
      <label>primary <input id="primary" type="color" value="#0052CC"></label>
      <label>secondary <input id="secondary" type="color" value="#00B8D9"></label>
      <label>width(px) <input id="width" type="number" min="320" step="1" value="1920"></label>
      <label>cell(px) <input id="cell" type="number" min="20" step="1" value="120"></label>
      <label>jitter(0-1) <input id="jitter" type="number" min="0" max="1" step="0.05" value="0.6"></label>
      <label>noise(0-1) <input id="noise" type="number" min="0" max="1" step="0.02" value="0.12"></label>
      <button id="regen">Перегенерировать</button>
      <button id="save">Скачать PNG</button>
    </div>
    <canvas id="cnv" width="1920" height="1080"></canvas>
  </div>

  <script>
    // ---------- Helpers ----------
    const clamp = (v, a=0, b=1) => Math.min(b, Math.max(a, v));
    const lerp  = (a, b, t) => a + (b - a) * t;

    function hexToRgb(hex) {
      hex = hex.trim();
      if (hex[0] === '#') hex = hex.slice(1);
      if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
      const n = parseInt(hex, 16);
      if (Number.isNaN(n) || hex.length !== 6) throw new Error('Expected #RRGGBB');
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHex({r,g,b}) {
      const h = v => v.toString(16).padStart(2,'0');
      return '#' + h(r) + h(g) + h(b);
    }
    function mixHex(aHex, bHex, t) {
      const a = hexToRgb(aHex), b = hexToRgb(bHex);
      return rgbToHex({
        r: Math.round(lerp(a.r, b.r, t)),
        g: Math.round(lerp(a.g, b.g, t)),
        b: Math.round(lerp(a.b, b.b, t)),
      });
    }

    // ---------- Core ----------
    function generateLowPolyPNG({
      primary = '#0052CC',
      secondary = '#00B8D9',
      width = 1920,       // output width; height keeps 16:9
      cell = 120,         // approx triangle size
      jitter = 0.6,       // random vertex offset for interior
      noise = 0.12,       // random color shift to avoid banding
      seed = undefined
    } = {}) {
      const height = Math.round(width * 9 / 16);

      const canvas = document.getElementById('cnv');
      const ctx = canvas.getContext('2d', { alpha:false });

      // handle device pixel ratio for crisp rendering
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width  = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      canvas.style.width  = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Seedable PRNG (Mulberry32)
      let s = typeof seed === 'number' ? seed >>> 0 : (Math.random() * 2**32) >>> 0;
      const rand = () => { s |= 0; s = (s + 0x6D2B79F5) | 0; let t = Math.imul(s ^ (s >>> 15), 1 | s); t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t; return ((t ^ (t >>> 14)) >>> 0) / 4294967296; };

      // Background gradient fully covering canvas
      const grad = ctx.createLinearGradient(0, 0, width, height);
      grad.addColorStop(0, primary);
      grad.addColorStop(1, secondary);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);


      // Build grid with border vertices pinned to edges
      const cols = Math.ceil(width / cell);
      const rows = Math.ceil(height / cell);
      const idx = (i, j) => j * (cols + 1) + i;
      const pts = new Array((cols + 1) * (rows + 1));

      for (let j = 0; j <= rows; j++) {
        for (let i = 0; i <= cols; i++) {
          const baseX = i * cell;
          const baseY = j * cell;

          // Use jitter only for interior points
          const offX = (i > 0 && i < cols) ? (rand() * 2 - 1) * cell * jitter : 0;
          const offY = (j > 0 && j < rows) ? (rand() * 2 - 1) * cell * jitter : 0;

          let x = baseX + offX;
          let y = baseY + offY;

          // Pin borders to frame so triangles reach edges
          if (i === 0)       x = 0;
          if (i === cols)    x = width;
          if (j === 0)       y = 0;
          if (j === rows)    y = height;

          pts[idx(i, j)] = { x, y };
        }
      }

      // Color function by centroid with diagonal mix
      function colorAt(x, y) {
        let t = ((x / width) + (y / height)) * 0.5;
        t = clamp(t + (rand() * 2 - 1) * noise, 0, 1);
        return mixHex(primary, secondary, t);
      }

      // Draw triangulated grid (two triangles per cell)
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
          const p00 = pts[idx(i, j)];
          const p10 = pts[idx(i + 1, j)];
          const p01 = pts[idx(i, j + 1)];
          const p11 = pts[idx(i + 1, j + 1)];

          const flip = rand() < 0.5;
          const tris = flip
            ? [[p00, p10, p11], [p00, p11, p01]]
            : [[p00, p10, p01], [p10, p11, p01]];

          for (const tri of tris) {
            const cx = (tri[0].x + tri[1].x + tri[2].x) / 3;
            const cy = (tri[0].y + tri[1].y + tri[2].y) / 3;
            ctx.fillStyle = colorAt(cx, cy);
            ctx.beginPath();
            ctx.moveTo(tri[0].x, tri[0].y);
            ctx.lineTo(tri[1].x, tri[1].y);
            ctx.lineTo(tri[2].x, tri[2].y);
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      return canvas.toDataURL('image/png');
    }

    // ---------- UI ----------
    const $ = s => document.querySelector(s);
    function readUI() {
      return {
        primary: $('#primary').value,
        secondary: $('#secondary').value,
        width: parseInt($('#width').value, 10),
        cell: parseInt($('#cell').value, 10),
        jitter: parseFloat($('#jitter').value),
        noise: parseFloat($('#noise').value),
      };
    }
    function render() { generateLowPolyPNG(readUI()); }

    $('#regen').addEventListener('click', render);
    $('#save').addEventListener('click', () => {
      const url = generateLowPolyPNG(readUI());
      const a = document.createElement('a');
      a.href = url;
      a.download = 'low-poly-16x9.png';
      a.click();
    });

    // initial render
    render();
  </script>
</body>
</html>

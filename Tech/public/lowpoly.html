<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Low‑poly 16:9 PNG</title>
  <style>
    body { margin:0; background:#111; color:#eee; font-family:system-ui,sans-serif; display:grid; place-items:center; gap:12px; padding:16px; }
    #wrap { display:grid; gap:8px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; }
    canvas { max-width:90vw; height:auto; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); }
    label { display:inline-flex; gap:6px; align-items:center; }
    input[type="color"], input[type="number"] { height:36px; }
    button { height:36px; padding:0 12px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="wrap">
    <div class="row">
      <label>primary <input id="primary" type="color" value="#0052CC"></label>
      <label>secondary <input id="secondary" type="color" value="#00B8D9"></label>
      <label>width(px) <input id="width" type="number" min="320" step="1" value="1920"></label>
      <label>cell(px) <input id="cell" type="number" min="0" step="1" value="120"></label>
      <label>jitter(0-1) <input id="jitter" type="number" min="0" max="1" step="0.05" value="0.6"></label>
      <label>noise(0-1) <input id="noise" type="number" min="0" max="1" step="0.02" value="0.12"></label>
      <button id="regen">Перегенерировать</button>
      <button id="gradient">Градиент</button>
      <button id="random">Случайный фон</button>
      <button id="save">Скачать PNG</button>
    </div>
    <canvas id="cnv" width="1920" height="1080"></canvas>
  </div>

  <script>
    // ---------- Helpers ----------
    const clamp = (v, a=0, b=1) => Math.min(b, Math.max(a, v));
    const lerp  = (a, b, t) => a + (b - a) * t;

    function hexToRgb(hex) {
      hex = hex.trim();
      if (hex[0] === '#') hex = hex.slice(1);
      if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
      const n = parseInt(hex, 16);
      if (Number.isNaN(n) || hex.length !== 6) throw new Error('Expected #RRGGBB');
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
    }
    function rgbToHex({r,g,b}) {
      const h = v => v.toString(16).padStart(2,'0');
      return '#' + h(r) + h(g) + h(b);
    }
    function mixHex(aHex, bHex, t) {
      const a = hexToRgb(aHex), b = hexToRgb(bHex);
      return rgbToHex({
        r: Math.round(lerp(a.r, b.r, t)),
        g: Math.round(lerp(a.g, b.g, t)),
        b: Math.round(lerp(a.b, b.b, t)),
      });
    }

    // HSL -> RGB (для осмысленной рандомизации цветов)
    function hslToRgb(h, s, l) {
      s /= 100; l /= 100;
      const c = (1 - Math.abs(2*l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c/2;
      let r1=0,g1=0,b1=0;
      if (0<=h && h<60)      { r1=c; g1=x; b1=0; }
      else if (60<=h && h<120){ r1=x; g1=c; b1=0; }
      else if (120<=h && h<180){ r1=0; g1=c; b1=x; }
      else if (180<=h && h<240){ r1=0; g1=x; b1=c; }
      else if (240<=h && h<300){ r1=x; g1=0; b1=c; }
      else                     { r1=c; g1=0; b1=x; }
      return {
        r: Math.round((r1 + m) * 255),
        g: Math.round((g1 + m) * 255),
        b: Math.round((b1 + m) * 255),
      };
    }
    const rgbToHexFast = (r,g,b) => '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');

    function randomPleasantPair() {
      const h1 = Math.floor(Math.random() * 360);
      const delta = 20 + Math.floor(Math.random() * 120); // различие по тону
      const h2 = (h1 + delta) % 360;
      const s1 = 60 + Math.floor(Math.random() * 30);     // 60–90%
      const s2 = 60 + Math.floor(Math.random() * 30);
      const l1 = 42 + Math.floor(Math.random() * 18);     // 42–60%
      const l2 = 42 + Math.floor(Math.random() * 18);
      const c1 = hslToRgb(h1, s1, l1);
      const c2 = hslToRgb(h2, s2, l2);
      return [rgbToHexFast(c1.r,c1.g,c1.b), rgbToHexFast(c2.r,c2.g,c2.b)];
    }


    // ---------- Core ----------
    function generateLowPolyPNG({
      primary = '#0052CC',
      secondary = '#00B8D9',
      width = 1920,       // output width; height keeps 16:9
      cell = 120,         // approx triangle size; 0 => gradient only
      jitter = 0.6,       // random vertex offset for interior
      noise = 0.12,       // random color shift to avoid banding
      seed = undefined
    } = {}) {
      const height = Math.round(width * 9 / 16);

      const canvas = document.getElementById('cnv');
      const ctx = canvas.getContext('2d', { alpha:false });

      // handle device pixel ratio
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width  = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      canvas.style.width  = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Background gradient fully covering canvas
      const grad = ctx.createLinearGradient(0, 0, width, height);
      grad.addColorStop(0, primary);
      grad.addColorStop(1, secondary);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      // Only gradient
      if (cell <= 0) return canvas.toDataURL('image/png');

      // Seedable PRNG (Mulberry32)
      let s = typeof seed === 'number' ? seed >>> 0 : (Math.random() * 2**32) >>> 0;
      const rand = () => { s |= 0; s = (s + 0x6D2B79F5) | 0; let t = Math.imul(s ^ (s >>> 15), 1 | s); t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t; return ((t ^ (t >>> 14)) >>> 0) / 4294967296; };

      // Build grid with border vertices pinned to edges
      const cols = Math.ceil(width / cell);
      const rows = Math.ceil(height / cell);
      const idx = (i, j) => j * (cols + 1) + i;
      const pts = new Array((cols + 1) * (rows + 1));

      for (let j = 0; j <= rows; j++) {
        for (let i = 0; i <= cols; i++) {
          const baseX = i * cell;
          const baseY = j * cell;
          const offX = (i > 0 && i < cols) ? (rand() * 2 - 1) * cell * jitter : 0;
          const offY = (j > 0 && j < rows) ? (rand() * 2 - 1) * cell * jitter : 0;

          let x = baseX + offX;
          let y = baseY + offY;

          if (i === 0)       x = 0;
          if (i === cols)    x = width;
          if (j === 0)       y = 0;
          if (j === rows)    y = height;

          pts[idx(i, j)] = { x, y };
        }
      }

      function colorAt(x, y) {
        let t = ((x / width) + (y / height)) * 0.5;
        t = clamp(t + (Math.random() * 2 - 1) * noise, 0, 1);
        return mixHex(primary, secondary, t);
      }

      // Draw triangles
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
          const p00 = pts[idx(i, j)];
          const p10 = pts[idx(i + 1, j)];
          const p01 = pts[idx(i, j + 1)];
          const p11 = pts[idx(i + 1, j + 1)];

          const flip = Math.random() < 0.5;
          const tris = flip
            ? [[p00, p10, p11], [p00, p11, p01]]
            : [[p00, p10, p01], [p10, p11, p01]];

          for (const tri of tris) {
            const cx = (tri[0].x + tri[1].x + tri[2].x) / 3;
            const cy = (tri[0].y + tri[1].y + tri[2].y) / 3;
            ctx.fillStyle = colorAt(cx, cy);
            ctx.beginPath();
            ctx.moveTo(tri[0].x, tri[0].y);
            ctx.lineTo(tri[1].x, tri[1].y);
            ctx.lineTo(tri[2].x, tri[2].y);
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      return canvas.toDataURL('image/png');
    }

    // ---------- UI ----------
    const $ = s => document.querySelector(s);
    function readUI() {
      return {
        primary: $('#primary').value,
        secondary: $('#secondary').value,
        width: parseInt($('#width').value, 10),
        cell: parseInt($('#cell').value, 10),
        jitter: parseFloat($('#jitter').value),
        noise: parseFloat($('#noise').value),
      };
    }
    function render() { generateLowPolyPNG(readUI()); }



    // Buttons
    $('#regen').addEventListener('click', render);
    $('#gradient').addEventListener('click', () => {
      const opts = readUI();
      opts.cell = 0;              // gradient-only mode
      generateLowPolyPNG(opts);
    });
    $('#random').addEventListener('click', () => {
      const [p, s] = randomPleasantPair();        // новые цвета
      $('#primary').value = p;
      $('#secondary').value = s;
      $('#cell').value   = Math.floor(80 + Math.random() * 120);  // 80–200 px
      $('#jitter').value = (0.35 + Math.random() * 0.5).toFixed(2); // 0.35–0.85
      $('#noise').value  = (0.06 + Math.random() * 0.14).toFixed(2); // 0.06–0.20
      render();
    });
    $('#save').addEventListener('click', () => {
      const url = generateLowPolyPNG(readUI());
      const a = document.createElement('a');
      a.href = url;
      a.download = 'low-poly-16x9.png';
      a.click();
    });

    // initial render
    render();
  </script>
</body>
</html>
